package rafradek.minecraft2source;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.lwjgl.opengl.GL11;

import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.EntityRenderer;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.OpenGlHelper;
import net.minecraft.client.renderer.RenderGlobal;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.texture.TextureAtlasSprite;
import net.minecraft.entity.Entity;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.World;
import net.minecraftforge.client.ClientCommandHandler;
import net.minecraftforge.client.event.RenderWorldLastEvent;
import net.minecraftforge.common.MinecraftForge;
import net.minecraftforge.common.config.Configuration;
import net.minecraftforge.common.config.Property;
import net.minecraftforge.event.world.WorldEvent;
import net.minecraftforge.fml.client.event.ConfigChangedEvent;
import net.minecraftforge.fml.common.Mod;
import net.minecraftforge.fml.common.ModMetadata;
import net.minecraftforge.fml.common.Mod.Metadata;
import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import rafradek.minecraft2source.Mark.MarkType;

@Mod(modid = "minecraft2source", name = "Minecraft map to Source", version = "1.0", guiFactory = "rafradek.minecraft2source.GuiFactory", clientSideOnly=true)
public class Minecraft2Source {
	
	public static final Logger LOGGER = LogManager.getLogger("Minecraft2Source");
	public static Configuration conf;
	public static Map<String, String> gamePathNames;
	public static String enginePath;
	public static File enginePathFile;
	public static File gamePathFile;
	public static String mapOutput;
	
	public static BlockPos sel1;
	public static BlockPos sel2;

	public static BlockRange range;
	
	@Metadata("minecraft2source")
	public static ModMetadata metadata;
	
	public static boolean occludersEnabled = false;
	public static int minOccluderVolume = 4;
	public static float blockSize = 48f;
	public static int lightmapScale = 16;
	public static boolean volumeSearch = true;
	public static int threadCount = 8;
	public static boolean allowFlatBrush = true;
	public static int sunBrightness=300;
	public static int blockBrightness=20;
	public static float maxHeightRamp = 0.5f;
	public static boolean rampTriangle = false;
	public static int boundaries = 0;
	
	public static List<EntityMark> entities;
	public static Map<String,EntityMark> entitiesMap;
	
	public static Field vboField;
    public static Field animationField;
    
	@Mod.EventHandler
	public void init(FMLPreInitializationEvent event) {
		
		metadata.autogenerated = false;
		conf = new Configuration(event.getSuggestedConfigurationFile());

		gamePathNames = new HashMap<>();
		gamePathNames.put("Team Fortress 2", "tf");
		
		syncConfig();
		MinecraftForge.EVENT_BUS.register(this);
		ClientCommandHandler.instance.registerCommand(new CommandBuildMap());
		ClientCommandHandler.instance.registerCommand(new CommandMarkPos("markpos1", false));
		ClientCommandHandler.instance.registerCommand(new CommandMarkPos("markpos2", true));
		ClientCommandHandler.instance.registerCommand(new CommandMarkPos("mp1", false));
		ClientCommandHandler.instance.registerCommand(new CommandMarkPos("mp2", true));
		ClientCommandHandler.instance.registerCommand(new CommandMarkEntity("markent"));
		ClientCommandHandler.instance.registerCommand(new CommandMarkEntity("me"));
		ClientCommandHandler.instance.registerCommand(new CommandMarkRemove("markrem"));
		ClientCommandHandler.instance.registerCommand(new CommandMarkRemove("mr"));
		ClientCommandHandler.instance.registerCommand(new CommandMarkProperty("markkeyvalue"));
		ClientCommandHandler.instance.registerCommand(new CommandMarkProperty("mkv"));
		ClientCommandHandler.instance.registerCommand(new CommandMarkSpecial("ms"));
		ClientCommandHandler.instance.registerCommand(new CommandMarkSpecial("markspecial"));
		ClientCommandHandler.instance.registerCommand(new CommandExportModel());
		ClientCommandHandler.instance.registerCommand(new CommandExportItem());
	}
	
	public void syncConfig() {
		enginePath = conf.getString("Game path", "path", "def", "Path to the game directory");
		mapOutput = conf.getString("Map output path", "path", "./maps", "Map output directory");
		new File(mapOutput).mkdirs();
		if (enginePath.equals("def")) {
			for (File root : File.listRoots()) {
				File steamdir = new File(root,"Program Files (x86)/Steam/steamapps/common");
				if (steamdir.exists()) {
					for (File file : steamdir.listFiles(filel -> filel.isDirectory())) {
						if (gamePathNames.containsKey(file.getName())) {
							enginePath = new File(file, gamePathNames.get(file.getName())).getAbsolutePath();
							mapOutput = new File(file,"sourcesdk_content/tf/mapsrc").getAbsolutePath();
							conf.get("path", "Game path", "def").set(enginePath);
							conf.get("Map output path", "Game path", "def").set(mapOutput);
						}
					}
				}
			}
		}
		occludersEnabled = conf.getBoolean("Occluders enabled", "general", false, "Automatically func_detail smaller brushes");
		minOccluderVolume = conf.getInt("Minimal occluder volume", "general", 8, 1, Integer.MAX_VALUE, "Minimal volume of brush that will not be converted to func_detail");
		blockSize= conf.getInt("Block size", "general", 48, 1, 1024, "Block size in hammer units. 36 allows for climbing stairs, 48 for regular jumping and 64 for crouch jump");
		lightmapScale= conf.getInt("Lightmap scale", "general", 16, 1, 1024, "Lightmap scale. Good value is (block size/3)");
		volumeSearch= conf.getBoolean("Volume search", "general", true, "Search for biggest block clusters first. Reduces brush count and visleaves, but heavily increaces build time");
		threadCount = conf.getInt("Thread count", "general", 8, 1, 256, "Number of threads used");
		allowFlatBrush = conf.getBoolean("Allow flat brush", "general", true, "Allow flat brushes");
		maxHeightRamp = conf.getFloat("Max ramp height", "general", 0.5f, 0f, 1f, "Maximal ramp height");
		sunBrightness = conf.getInt("Sun brightness", "general", 300, 0, 8000, "Maximal sun brightness");
		blockBrightness = conf.getInt("Block brightness", "general", 300, 0, 8000, "Maximal brightness from block sources")/15;
		rampTriangle = conf.getBoolean("Sloped ramp", "general", false, "Should use sloped ramps rather than steps");
		boundaries = getIndexSelected(conf.get("general", "Boundaries", "skybox").setValidValues(new String[] {"skybox","cordon","none"}),0);
		gamePathFile = new File(enginePath);
		enginePathFile = new File(gamePathFile.getParentFile(), "bin");
		if (conf.hasChanged())
			conf.save();
	}
	
	public static int getIndexSelected(Property prop, int def) {
		if (prop.getValidValues() != null) {
			for (int i = 0; i < prop.getValidValues().length; i++) {
				if (prop.getString().equalsIgnoreCase(prop.getValidValues()[i]))
					return i;
			}
		}
		return def;
	}
	
	@SubscribeEvent
	public void onConfigChanged(ConfigChangedEvent.OnConfigChangedEvent eventArgs) {
		// TF2weapons.syncConfig();
		if (eventArgs.getModID().equals("minecraft2source")) {
			syncConfig();
		}
	}
	
	@SubscribeEvent
	public void onConfigChanged(ConfigChangedEvent.PostConfigChangedEvent eventArgs) {
		// TF2weapons.syncConfig();
		if (eventArgs.getModID().equals("minecraft2source")) {
			syncConfig();
		}
	}
	
	@SubscribeEvent
	public void renderWorld(RenderWorldLastEvent event) {
		if (Minecraft.getMinecraft().getRenderManager().options != null) {
			Entity camera = Minecraft.getMinecraft().getRenderViewEntity();
			double cameraX = camera.prevPosX + (camera.posX - camera.prevPosX) * event.getPartialTicks();
			double cameraY = camera.prevPosY + (camera.posY - camera.prevPosY) * event.getPartialTicks();
			double cameraZ = camera.prevPosZ + (camera.posZ - camera.prevPosZ) * event.getPartialTicks();
			
			if (entities != null) {
				for (Mark mark : entities) {
					for (BlockRange range : mark.range) {
			            float f = Minecraft.getMinecraft().getRenderManager().playerViewY;
			            float f1 = Minecraft.getMinecraft().getRenderManager().playerViewX;
			            boolean flag1 = Minecraft.getMinecraft().getRenderManager().options.thirdPersonView == 2;
			            EntityRenderer.drawNameplate(Minecraft.getMinecraft().fontRenderer, mark.name, (float)(range.maxX-cameraX), (float)(range.maxY-cameraY)+1.2f, (float)(range.maxZ-cameraZ)
			            		, 0, f, f1, flag1, false);
			            
			            GlStateManager.pushMatrix();
			    		GlStateManager.disableTexture2D();
			    		GlStateManager.disableLighting();
			    		GL11.glEnable(GL11.GL_BLEND);
			    		OpenGlHelper.glBlendFunc(770, 771, 1, 0);
			    		int color = mark.hashCode()&0xFFFFFF;
						RenderGlobal.drawBoundingBox(range.minX-cameraX, range.minY-cameraY, range.minZ-cameraZ, range.maxX+1.0-cameraX, range.maxY+1.0-cameraY, range.maxZ+1.0-cameraZ, 
								(color >> 16)/255f, ((color >> 8) & 255)/255f, (color & 255)/255f, 1);
						GL11.glDisable(GL11.GL_BLEND);
						GlStateManager.enableTexture2D();
						GlStateManager.enableLighting();
						GlStateManager.popMatrix();
					}
				}
			}
			if (range != null) {
				GL11.glLineWidth(2);
				GlStateManager.pushMatrix();
	    		GlStateManager.disableTexture2D();
	    		GlStateManager.disableLighting();
	    		GL11.glEnable(GL11.GL_BLEND);
	    		OpenGlHelper.glBlendFunc(770, 771, 1, 0);
				RenderGlobal.drawBoundingBox(range.minX-cameraX, range.minY-cameraY, range.minZ-cameraZ, range.maxX+1.0-cameraX, range.maxY+1.0-cameraY, range.maxZ+1.0-cameraZ, 1, 0, 1, 1);
				GL11.glDisable(GL11.GL_BLEND);
				GlStateManager.enableTexture2D();
				GlStateManager.enableLighting();
				GlStateManager.popMatrix();
				GL11.glLineWidth(1);
			}
		}
	}
	
	@SubscribeEvent
	public void loadWorld(WorldEvent.Load event) {
		
		if (event.getWorld().isRemote) {
			if (entities != null) {
				saveMarks(event.getWorld());
			}
			entities = new ArrayList<>();
			entitiesMap = new HashMap<>();
			File worldfile = new File("./config/entitymarks",getWorldName(event.getWorld()));
			if (worldfile.exists()) {
				try {
					DataInputStream data = new DataInputStream(new FileInputStream(worldfile));
					int version = data.readByte();
					while(data.available()>0) {
						EntityMark mark = new EntityMark();
						mark.read(data, version);
						entities.add(mark);
						entitiesMap.put(mark.name, mark);
					}
					data.close();
				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
		}
	}
	public void saveMarks(World world) {
		if (world.isRemote) {
			File worldfile = new File("./config/entitymarks",getWorldName(world));
			if (!worldfile.getParentFile().exists())
				worldfile.getParentFile().mkdirs();
			try {
				DataOutputStream data = new DataOutputStream(new FileOutputStream(worldfile));
				data.writeByte(1);
				for (Mark mark : entities) {
					mark.write(data);
				}
				data.flush();
				data.close();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}
	@SubscribeEvent
	public void unloadWorld(WorldEvent.Unload event) {
		if (event.getWorld().isRemote && entities != null) {
			saveMarks(event.getWorld());
			
			entities = null;
			
			entitiesMap = null;
		}
	}
	
	public static String getWorldName(World world) {
		String worldname;
    	if (Minecraft.getMinecraft().getIntegratedServer() != null) {
    		worldname = Minecraft.getMinecraft().getIntegratedServer().worlds[0].getWorldInfo().getWorldName();
    	}
    	else {
    		worldname = world.getWorldInfo().getWorldName();
    	}
    	worldname = worldname.replace(' ', '_');
    	worldname += "_"+world.provider.getDimension();
    	return worldname;
	}
	static {
		for (Field field : Tessellator.class.getDeclaredFields()) {
			if (field.getName().equals("vboUploader")) {
				vboField = field;
				field.setAccessible(true);
				break;
			}
		}
		
		for (Field field : TextureAtlasSprite.class.getDeclaredFields()) {
			if (field.getName().equals("animationMetadata")) {
				animationField = field;
				field.setAccessible(true);
				break;
			}
		}
	}
	
}
